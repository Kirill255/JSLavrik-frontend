// для примера собственного итератора расскомментировать строку /* global Symbol*/

// '  Всем    привет!    Ура   ура!   '
// str.trim() - обрезает пробелы только в начале и в конце строки
// а также нужно заменить любое кол-во пробелов между словами на один пробел, внутри строки
// получается что это у нас приватная функция, т.к. она не экспортируется из модуля
function strippedWhitespace(str) {
  return str.trim().replace(/\s+/g, " ");
}

function wordsCount(str) {
  return strippedWhitespace(str).split(" ").length;
}

// можно просто вернуть массив, но по условию задачи нам нельзя возвращать массив

// function getWords(str) {
//   return strippedWhitespace(str).split(" ");
// }

// тогда пишем свой собстенный итератор, но в нём практически нет смысла, т.к. нам всё равно приходиться использовать массив, вернее разбивать строку на массив и потом перебирать его в собственном итераторе, плюс ещё писать сам итератор, кароче это просто кривое решение

// function getWords(str) {
//   return {
//     words: strippedWhitespace(str).split(" "),
//     [Symbol.iterator]() {
//       let i = 0;

//       return {
//         next: () => {
//           if (i < this.words.length) {
//             return {
//               done: false,
//               value: this.words[i++]
//             };
//           } else {
//             return {
//               done: true
//             };
//           }
//         }
//       };
//     }
//   };
// }

// напишем функцию-генератор, функция-генератор нужна в первую очередь чтобы не писать свой итератор =)
// но в этом решении мы пока всё ещё используем массив, фактически это такое же решение как и с собстенным итератором, только чтобы не писать этот самый собстенный итератор, мы используем функцию-генератор

// function* getWords(str) {
//   let words = strippedWhitespace(str).split(" ");

//   for (let i = 0; i < words.length; i++) {
//     yield words[i];
//   }
// }

// или так тоже самое, другой цикл

// function* getWords(str) {
//   let words = strippedWhitespace(str).split(" ");

// for (let key in words) {
//   yield words[key];
// }
// }

// теперь нормальное решение
// =========================

// function* getWords(str) {
//   // 'Всем привет! Ура ура!'
//   let text = strippedWhitespace(str) + " "; // зачем нужно добавить в конце пробел, написано ниже
//   let start = 0;
//   // текущий элемент это первое слово до пробела '^Всем| привет! Ура ура!', ^ - start, | - докуда искать, в нашем случае до перого пробела, метод .indexOf() возвращает первый найденный элемент, а также вторым аргументом принимает позицию с которой начать поиск, тоесь в первом случае от 0 до перого найденного пробела
//   let current = text.indexOf(" ", start);

//   // теперь если .indexOf() не находит, то что искал, он возвращает -1, тоесть больше нет пробелов
//   while (current !== -1) {
//     yield text.substr(start, current - start); // ну и выкидываем подстроки(наши слова) в yield
//     // а дальше нужно обновить обе наши переменные 'Всем ^привет!| Ура ура!'
//     start = current + 1;
//     current = text.indexOf(" ", start);
//   }
// }

// когда мы дойдём до последнего слова, start(начало слова) у нас будет, а последнего пробела для поиска и взятия подстроки(конца слова) не будет 'Всем привет! Ура ^ура!' <- вот тут уже нет пробела, наш цикл просто вернёт -1 и заершится и последнее слово не будет возвращено в yield, поэтому мы сделаем лайфхак, добавим в конце строки один пробел 'Всем привет! Ура ^ура!| ' <- сюда, мы выкинем в yield послднее слово, дальше каретка снова передвинется 'Всем привет! Ура ура! ^' и теперь т.к. больше пробелов не будет найдено, цикл завершится

function* getWords(str) {
  let text = strippedWhitespace(str) + " ";
  let start = 0;
  let current = text.indexOf(" ", start);

  while (current !== -1) {
    yield text.substr(start, current - start);
    start = current + 1;
    current = text.indexOf(" ", start);
  }
}

export { wordsCount, getWords };
